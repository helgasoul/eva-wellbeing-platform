// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://wbydubxjcdhoinhrozwx.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndieWR1YnhqY2Rob2luaHJvend4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAwNjI2MjgsImV4cCI6MjA2NTYzODYyOH0.A_n3yGRvALma5H9LTY6Cl1DLwgLg-xgwIP2slREkgy4";

// Environment and connection monitoring
const isProduction = window.location.hostname !== 'localhost';
const isDevelopment = !isProduction;

console.log('üöÄ Supabase Client Initialization:', {
  url: SUPABASE_URL,
  environment: isProduction ? 'production' : 'development',
  hostname: window.location.hostname
});

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: typeof window !== 'undefined' ? localStorage : undefined,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
    debug: isDevelopment
  },
  global: {
    headers: {
      'apikey': SUPABASE_PUBLISHABLE_KEY,
      'X-Client-Info': `bloom-app-${isProduction ? 'prod' : 'dev'}`
    },
    fetch: (url, options: any = {}) => {
      const startTime = Date.now();
      
      // –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π —Ç–∞–π–º–∞—É—Ç –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
      const isAuthRequest = url.includes('/auth/') || url.includes('/rest/v1/user_profiles');
      const timeout = isAuthRequest ? 60000 : 30000; // 60s –¥–ª—è auth, 30s –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö
      
      const fetchWithRetry = async (retryCount = 0): Promise<Response> => {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
            headers: {
              ...(options.headers || {}),
              'Keep-Alive': 'timeout=60, max=100',
              'Connection': 'keep-alive'
            }
          });
          
          clearTimeout(timeoutId);
          const duration = Date.now() - startTime;
          
          if (isDevelopment) {
            console.log(`üåê Supabase Request: ${url} (${duration}ms)`, {
              status: response.status,
              ok: response.ok,
              retry: retryCount > 0 ? retryCount : undefined
            });
          }
          
          // Retry –ª–æ–≥–∏–∫–∞ –¥–ª—è 5xx –æ—à–∏–±–æ–∫, 429, –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö 4xx
          if (!response.ok && retryCount < 3) {
            const shouldRetry = response.status >= 500 || 
                               response.status === 429 || 
                               response.status === 408 ||
                               response.status === 0;
            
            if (shouldRetry) {
              const retryDelay = Math.min(Math.pow(2, retryCount) * 1000 + Math.random() * 1000, 10000);
              console.warn(`‚ö†Ô∏è Server error ${response.status}, retrying in ${retryDelay}ms... (attempt ${retryCount + 1})`);
              await new Promise(resolve => setTimeout(resolve, retryDelay));
              return fetchWithRetry(retryCount + 1);
            }
          }
          
          return response;
        } catch (error) {
          const duration = Date.now() - startTime;
          
          // Retry –¥–ª—è network errors –∏ timeouts
          if (retryCount < 3 && (
            error instanceof Error && (
              error.name === 'AbortError' || 
              error.name === 'TypeError' ||
              error.message.includes('network') ||
              error.message.includes('timeout') ||
              error.message.includes('Load failed') ||
              error.message.includes('fetch')
            )
          )) {
            const retryDelay = Math.min(Math.pow(2, retryCount) * 1000 + Math.random() * 1000, 10000);
            console.warn(`‚ö†Ô∏è Network error, retrying in ${retryDelay}ms... (attempt ${retryCount + 1})`, error.message);
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            return fetchWithRetry(retryCount + 1);
          }
          
          console.error(`‚ùå Supabase Request Failed: ${url} (${duration}ms)`, {
            error: error.message,
            name: error.name,
            retries: retryCount
          });
          throw error;
        }
      };
      
      return fetchWithRetry();
    }
  },
  db: {
    schema: 'public'
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  }
});

// Connection health monitoring
let connectionCheckInterval: NodeJS.Timeout;

export const initializeSupabaseMonitoring = () => {
  if (connectionCheckInterval) {
    clearInterval(connectionCheckInterval);
  }

  // Check connection health every 30 seconds in production
  if (isProduction) {
    connectionCheckInterval = setInterval(async () => {
      try {
        const { data, error } = await supabase.from('user_profiles').select('id').limit(1);
        if (error) {
          console.warn('‚ö†Ô∏è Supabase health check failed:', error.message);
        }
      } catch (error) {
        console.error('‚ùå Supabase connection error:', error);
      }
    }, 30000);
  }
};

// Initialize monitoring when client is created
if (typeof window !== 'undefined') {
  initializeSupabaseMonitoring();
}